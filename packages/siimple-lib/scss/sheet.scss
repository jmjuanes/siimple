@use "sass:list";
@use "sass:map";
@use "sass:string";

@use "./breakpoints.scss" as breakpoints;
@use "./constants.scss" as constants;
@use "./naming.scss" as naming;
@use "./scales.scss" as scales;
@use "./utils.scss" as utils;

// @description Generate a flat version fo the specified rules
@function parse-styles ($classname, $rules) {
    $styles: utils.empty-map();
    $styles: map.set($styles, $classname, utils.empty-map());
    @each $key,$rule in $rules {
        // Check for map value
        @if utils.is-map($rule) {
            // Check if rule starts with the '@' character
            @if utils.starts-with($key, "@") {
                $new-styles: parse-styles($classname, $rule);
                $styles: utils.set-in($styles, $key, $new-styles);
            }
            // Other value --> parse as nested styles
            @else {
                $new-classname: utils.replace($key, "&", $classname);
                $new-styles: parse-styles($new-classname, $rule);
                $styles: map.merge($styles, $new-styles);
            }
        }
        //@if utils.is-string($rule) {
        @else {
            // Check for alias -> register the same value in all aliases keys
            @if map.has-key(constants.$css-aliases, $key) {
                $key-aliases: map.get(constants.$css-aliases, $key);
                @each $key-alias in $key-aliases {
                    $styles: utils.set-in($styles, ($classname $key-alias), $rule);
                } 
            }
            // If no aliases are defined --> register this rule
            @else {
                $styles: utils.set-in($styles, ($classname $key), $rule);
            }
        }
    }
    // Return styles
    @return $styles;
}

// @description Merge two styles objects
@function merge-styles ($source, $target) {
    @return map.deep-merge($source, $target);
}

// @description Build styles
@mixin build-styles ($styles) {
    @each $selector,$rules in $styles {
        // Check for breakpoint selector
        @if breakpoints.is-breakpoint-selector($selector) {
            $breakpoint: breakpoints.get-breakpoint-from-selector($selector);
            @include breakpoints.use-breakpoint($breakpoint) {
                @include build-styles($rules);
            }
        }
        // Check for media rules --> process as nested rules
        @else if utils.starts-with($selector, "@media") {
            @media #{utils.unquote(utils.replace($selector, "@media ", ""))} {
                @include build-styles($rules);
            }
        }
        // If is not a media rule, add each rule
        @else if not utils.starts-with($selector, "@") {
            #{utils.unquote($selector)} {
                @each $prop,$value in $rules {
                    $is-important: false;
                    // Check for list value --> check for flags
                    @if utils.is-list($value) {
                        $last-item: utils.last-item($value);
                        @if $last-item == "important" or $last-item == "!important" {
                            $is-important: true;
                        }
                        $value: utils.first-item($value);
                    }
                    // Generate this property
                    @include scales.use-scale($prop, $value, $is-important);
                }
            }
        }
        // Other rule --> throw error
        @else {
            @error "Unexpected rule '#{$selector}'.";
        }
    }
}

// @description Build variables block
@mixin build-variables ($variables) {
    :root {
        @each $varname,$value in $variables {
            @if utils.starts-with($varname, "--") {
                $varname: string.slice($varname, 3);
            }
            --#{$varname}: #{utils.unquote($value)};
        }
    }
}

// @description Create a new empty sheet object
@function create-sheet () {
    @return (
        "styles": utils.empty-map(),
        "fonts": utils.empty-list(),
        "variables": utils.empty-map(),
        "keyframes": utils.empty-map(),
    );
}

// @description Register a new classname to the sheet
// @param {string} $key classname key to be used in rules
// @param {string} $name classname to assign to the previous key
//@function add-classname-to-sheet($sheet: (), $key: "", $name: "") {
//    @return utils.set-in($sheet, ("classnames" $key), $name);
//}

// @description Add a new rule to the object
@function add-styles-to-sheet ($sheet, $classname, $rules) {
    //@debug "Adding '#{$classname}' styles to sheet... OK";
    $old-styles: utils.get-in($sheet, "styles", utils.empty-map());
    $new-styles: _parse-styles($classname, $rules);
    $merged-styles: _merge-styles($old-styles, $new-styles);
    @return map.set($sheet, "styles", $merged-styles); 
} 

// @description Register a new variable in the sheet
@function add-variable-to-sheet ($sheet, $varname, $value) {
    //@debug "Adding '#{$varname}' variable to sheet... OK";
    @return utils.set-in($sheet, ("variables" $varname), $value);
}

// @description Register a new keyframe in the sheet
@function add-keyframes-to-sheet ($sheet, $name, $options) {
    $new-keyframes: map.get($sheet, "keyframes");
    //$name: map.get($keyframes, "name");
    //$steps: map.get($keyframes, "steps");
    $steps: utils.empty-map();
    //@each $step-name,$step-rules in map.get($options, "steps") {
    @each $step-name,$step-rules in $options {
        $steps: map.merge(
            $steps,
            parse-styles($step-name, $step-rules)
        );
    }
    //@debug "Adding '#{$name}' keyframe to sheet... OK";
    $new-keyframes: map.set($new-keyframes, $name, $steps);
    @return map.set($sheet, "keyframes", $new-keyframes);
}

// @description Register a new font in the sheet
@function add-font-to-sheet ($sheet, $name, $options) {
    //$name: map.get($options, "name");
    $sources: "";
    @each $type,$url in map.get($options, "sources") {
        $sources: $sources + ",url(#{$url}) format(\"#{$type}\")"; 
    }
    $new-fonts: map.get($sheet, "fonts");
    $new-fonts: list.append($new-fonts, (
        "font-family": $name,
        "font-style": utils.get-in($options, "style", "normal"),
        "font-weight": utils.get-in($options, "weight", "normal"),
        "src": string.slice($sources, 2),
    ));
    //@debug "Adding '#{$name}' font to sheet... OK";
    @return map.set($sheet, "fonts", $new-fonts);
}

// @description Compile sheet
@mixin compile-sheet ($sheet) {
    //@debug "Compiling sheet";
    @include build-variables($sheet, map.get($sheet, "variables"));
    // Register fonts
    $sheet-fonts: map.get($sheet, "fonts");
    @each $font-rules in $sheet-fonts {
        @font-face {
            font-family: map.get($font-rules, "font-family");
            font-style: utils.unquote(map.get($font-rules, "font-style"));
            font-weight: utils.unquote(map.get($font-rules, "font-weight"));
            src: utils.unquote(map.get($font-rules, "src"));
        }
    }
    // Register keyframes
    @each $keyframe-name,$keyframe-rules in map.get($sheet, "keyframes") {
        @keyframes #{utils.unquote($keyframe-name)} {
            @include build-styles($keyframe-rules);
        }
    }
    @include build-styles(map.get($sheet, "styles"));
}

// @description shortcut for building sheets
@mixin use-sheet ($options) {
    @error "Not implemented yet...";
}

// @description generate a fort-face
@mixin use-font ($name, $options) {
    $sheet: create-sheet();
    $sheet: add-font-to-sheet($sheet, $name, $options);
    @include compile-sheet($sheet);
}

// @description sortcut to generate a keyframes
@mixin use-keyframes ($name, $options) {
    $sheet: create-sheet();
    $sheet: add-keyframes-to-sheet($sheet, $name, $options);
    @include compile-sheet($sheet);
}

